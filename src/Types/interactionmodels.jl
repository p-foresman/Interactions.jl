#NOTE: fix documentation!
"""
    InteractionModel

An abstract type representing all interaction parameter types.
"""
abstract type InteractionModel end

"""
    GraphModel

An abstract type representing the class of graph interaction parameters.
"""
struct GraphModel <: InteractionModel #NOTE: want to refactor graphmodel to act more like Model (parameters is a Dict{Symbol=>Float64}, graphs are then generated by passing in the graphmodel itself as the sole argument and the user is responsible for getting the parameters. In this way, we might be able to scrap the graphmodel in general and just use a graphmodel function)
    populations_size::Int #required parameter to make GraphModel self-contained (not rely on Model)
    fn_var::Symbol
    params::NamedTuple #(param=arg,) notation
    param_types::Tuple #might not need
    kwargs::Dict{Symbol, Any}

    function GraphModel(population_size::Integer, fn_var::Symbol, args::NamedTuple, kwargs::Dict{Symbol, <:Any}=Dict{Symbol, Any}())
        # @assert #make sure fn_var is in Registry.GraphModels
        isdefined(Registry.GraphModels, fn_var) || throw(Registry.NotDefinedError(fn_var, Symbol("@graphmodel")))
        # @assert all(i -> isa(i, Real), values(args)) "All args must be <:Real" #NOTE: should we require this?
        f = getfield(Registry.GraphModels, fn_var) #get the function
        arg_types = map(arg->typeof(arg), collect(args))
        m = which(f, (Integer, arg_types...)) #get the method associated with the arg types provided. This will error if the arguments provided don't match the type specifications for the Function
        param_types = Base.arg_decl_parts(m)[2][3:end] #first index is function name, second should be Integer type
        arg_names = keys(args)
        for i in eachindex(param_types) #ensure the orders of arguments are right. If these are right, args is sufficiently validated since type validation was completed previously
            Symbol(param_types[i][1]) == arg_names[i] || throw(ErrorException("arguments provided must be in the order of the function parameters"))
        end
        # println(Base.return_types(f, (Model, arg_types...))[1])
        # Base.return_types(f, (Model, arg_types...))[1] <: Graphs.SimpleGraph || throw(DomainError(fn_var, "The corresponding function must return a Graphs.SimpleGraph")) #NOTE: FIX. user-defined graphmodels are currently printing Any as return type
        return new(population_size, fn_var, args, Tuple(arg_types), kwargs) #(; zip(params , ordered_args)...)
    end
    GraphModel(population_size::Integer, fn_var::Symbol; kwargs::Dict{Symbol, <:Any}=Dict{Symbol, Any}(), args...) = GraphModel(population_size, fn_var, NamedTuple(args), kwargs)
end

population_size(graphmodel::GraphModel) = getfield(graphmodel, :population_size)
graphmodel_fn_var(graphmodel::GraphModel) = getfield(graphmodel, :fn_var)
graphmodel_fn_name(graphmodel::GraphModel) = string(graphmodel_fn_var(graphmodel))
graphmodel_fn(graphmodel::GraphModel) = getfield(Registry.GraphModels, graphmodel_fn_var(graphmodel))
parameters(graphmodel::GraphModel) = getfield(graphmodel, :params)
args(graphmodel::GraphModel) = values(parameters(graphmodel))
kwargs(graphmodel::GraphModel) = getfield(graphmodel, :kwargs)


"""
    displayname(graphmodel::GraphModel)

Get the string used for displaying a GraphModel instance.
"""
displayname(graphmodel::GraphModel) = "$(fn_name(graphmodel))$(isempty(parameters(graphmodel)) ? "" : " $(parameters(graphmodel))")"
Base.show(graphmodel::GraphModel) = println(displayname(graphmodel))

#NOTE: probably do want this here, but want it to be self contained to GraphModel?
function generate_graph(graphmodel::GraphModel)::Graphs.SimpleGraph
    graph::Graphs.SimpleGraph = graphmodel_fn(graphmodel)(population_size(graphmodel), args(graphmodel)...; kwargs(graphmodel)...)
    if Graphs.ne(graph) == 0 #NOTE: we aren't considering graphs with no edges (obviously). Does it even make sense to consider graphs with more than one component?
        return generate_graph(graphmodel)
    end
    return graph
end